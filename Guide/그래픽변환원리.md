# 🎨 ASCII Doom: 그래픽 변환 원리

이 문서는 Doom 게임 화면이 어떻게 **ASCII 문자**로 변환되는지 그 과정을 설명합니다.

---

## 1. 변환 개요

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   게임 엔진       │ ──▶ │  변환 파이프라인   │ ──▶ │   화면 출력       │
│  (Chocolate Doom) │     │  (i_ascii.cpp)   │     │  (renderer.js)  │
│   320×200 픽셀   │     │   RGBA → ASCII   │     │   240×80 문자   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

*   **입력**: 320×200 해상도의 RGBA 픽셀 버퍼 (64,000개 픽셀)
*   **출력**: 240×80 크기의 ASCII 문자 그리드 (19,200개 문자)
*   **반복**: 이 과정이 **1초에 약 35번** 실행됩니다.

---

## 2. 변환 파이프라인 (5단계)

### ① 다운샘플링 (해상도 축소)
픽셀 하나가 문자 하나보다 훨씬 작으므로, 여러 픽셀을 묶어서 하나의 문자로 대응시켜야 합니다.
*   **원본**: 320×200 = 64,000 픽셀
*   **타겟**: 240×80 = 19,200 문자
*   각 문자 셀은 대략 **1.33×2.5 픽셀** 영역을 담당합니다.
*   이 영역에 속한 모든 픽셀의 **평균 색상**을 구합니다.

### ② 적분 영상 생성 (Integral Image)
평균 색상을 빠르게 구하기 위한 **최적화 기법**입니다.

**문제**: 19,200개 셀에 대해 매번 픽셀들을 일일이 더하면 느립니다.
**해결**: 미리 **"누적 합 테이블"**을 만들어 둡니다.

```
원본 이미지:           누적 합 테이블 (적분 영상):
┌───┬───┬───┐         ┌───┬───┬───┐
│ 1 │ 2 │ 3 │         │ 1 │ 3 │ 6 │  ← 가로 방향 누적
├───┼───┼───┤   ──▶   ├───┼───┼───┤
│ 4 │ 5 │ 6 │         │ 5 │12 │21 │  ← 가로+세로 누적
└───┴───┴───┘         └───┴───┴───┘
```

이 테이블이 있으면 **어떤 직사각형 영역의 합**이든 **뺄셈 3번**으로 즉시 계산할 수 있습니다.
*   `영역 합 = 우하단 - 우상단 - 좌하단 + 좌상단`

### ③ 밝기(휘도) 계산
평균 RGB 값을 사람의 눈이 느끼는 **밝기(Luminance)**로 변환합니다.
*   공식: `Y = R×0.299 + G×0.587 + B×0.114`
*   결과: **0(완전 어두움) ~ 255(완전 밝음)** 사이의 값

### ④ 감마 보정 (Gamma Correction)
문자 사이사이에 검은 여백이 있어서 화면이 원본보다 **어둡게 느껴집니다**.
이를 보정하기 위해 밝기 값을 인위적으로 **밝게 조정**합니다.
*   사용 감마: `0.35` (기본 1.0보다 밝게)
*   `gamma_table[i]`에 미리 계산된 보정 값을 저장해두고 즉시 조회합니다.

### ⑤ 문자 매핑 (ASCII Mapping)
최종 밝기 값에 해당하는 **ASCII 문자**를 선택합니다.

```
밝기 스케일:
어두움 ◀━━━━━━━━━━━━━━━━━━━━━━━▶ 밝음
 @ % # * + = - : .   (공백)
```

*   **0 (칠흑)**: `@` (가장 촘촘한 문자)
*   **128 (중간)**: `+` 또는 `=`
*   **255 (눈부심)**: ` ` (공백, 빈 문자)

밝기→문자 변환도 **`idxLUT[brightness]`** 테이블로 미리 계산해두어 연산을 최소화합니다.

---

## 3. 성능 최적화: SIMD

위 과정에서 가장 무거운 연산인 **"밝기 계산"**을 더 빠르게 하기 위해 **SIMD**를 사용합니다.

### SIMD란?
*   **Single Instruction, Multiple Data**의 약자입니다.
*   CPU에게 "이 숫자 4개를 **동시에** 계산해"라고 명령하는 기술입니다.

### 적용 방식
```
┌─────────────────────────────────────────────────────┐
│               보통 루프 (스칼라)                       │
│  픽셀1 계산 → 픽셀2 계산 → 픽셀3 계산 → 픽셀4 계산     │
│     ↓ (순차 처리)                                    │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│               SIMD 루프 (벡터)                        │
│  [ 픽셀1, 픽셀2, 픽셀3, 픽셀4 ] 동시 계산!            │
│     ↓ (병렬 처리, 이론상 4배 빠름)                    │
└─────────────────────────────────────────────────────┘
```

*   **WASM SIMD128**: 128비트(16바이트) 레지스터에 4개의 32비트 정수를 담아 한 번에 계산합니다.

---

## 4. 최종 출력

변환된 결과는 **`AsciiCell`** 구조체 배열로 저장됩니다.
```c
struct AsciiCell {
    char    character;  // 문자 ('@', '#', '+', ...)
    uint8_t r, g, b;    // 원본 색상 (감마 보정 후)
};
```

자바스크립트(`renderer.js`)는 이 배열을 읽어서:
1.  문자(`character`)를 Canvas에 찍습니다.
2.  색상(`r, g, b`)을 `fillStyle`로 적용하여 **컬러 ASCII 아트**를 완성합니다.
