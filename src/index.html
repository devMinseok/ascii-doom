<!DOCTYPE html>
<html lang="en-us">
    <head>
        <title>Websockets Doom - TERMINAL</title>
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
        <style>
            @font-face {
                font-family: "VT323";
                font-style: normal;
                font-weight: 400;
                src: url(https://fonts.gstatic.com/s/vt323/v12/pxiKyp0ihIEF2isfFJXUdVNF.woff2) format("woff2");
                unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
            }

            * {
                box-sizing: border-box;
            }

            html {
                font-family: "VT323", monospace;
                font-size: 16px;
                height: 100%;
                overflow: hidden;
            }

            body {
                background-color: #050505;
                background-image: 
                    linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                    linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(255, 0, 0, 0.02));
                background-size: 100% 2px, 3px 100%;
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                color: #d32f2f;
            }

            /* 모니터 전체 프레임 */
            #container {
                position: relative;
                width: 95vw;
                max-width: 1600px;
                height: 90vh; /* 높이를 화면의 90%로 고정 */
                aspect-ratio: 4/3;
                border: 4px solid #444;
                border-radius: 20px;
                background: #000;
                box-shadow: 
                    0 0 0 4px #1a1a1a,
                    0 0 50px rgba(220, 20, 60, 0.4),
                    inset 0 0 100px rgba(0,0,0,0.9);
                padding: 30px; /* 패딩을 조금 줄임 */
                display: flex;
                flex-direction: column; /* 세로 정렬 */
                justify-content: space-between; /* 위아래 요소 분배 */
                align-items: center;
                overflow: hidden; /* 밖으로 나가는 것 방지 */
            }

            /* 상단 장식용 헤더 */
            .monitor-header {
                width: 100%;
                display: flex;
                justify-content: space-between;
                padding: 0 10px 10px 10px;
                border-bottom: 2px solid #333;
                margin-bottom: 10px;
                color: #ff3333;
                text-shadow: 0 0 5px #ff3333;
                font-size: 1.2rem;
                letter-spacing: 2px;
                flex-shrink: 0; /* 크기 줄어들지 않게 고정 */
            }

            .blink {
                animation: blinker 1s linear infinite;
            }
            @keyframes blinker {
                50% { opacity: 0; }
            }

            /* 캔버스 래퍼 (화면 안쪽) */
            .screen-wrapper {
                position: relative;
                width: 100%;
                flex: 1; /* 남은 공간을 모두 차지하도록 설정 */
                min-height: 0; /* Flex item이 내용물보다 작아질 수 있게 허용 */
                overflow: hidden;
                border: 2px solid #222;
                border-radius: 4px;
                box-shadow: inset 0 0 20px rgba(0,0,0,1);
                background-color: #000;
            }

            canvas.frame {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                image-rendering: pixelated;
                display: block;
            }

            /* CRT 스캔라인 효과 */
            .crt-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                background: linear-gradient(
                    to bottom,
                    rgba(255,255,255,0),
                    rgba(255,255,255,0) 50%,
                    rgba(0,0,0,0.2) 50%,
                    rgba(0,0,0,0.2)
                );
                background-size: 100% 4px;
                z-index: 10;
                box-shadow: inset 0 0 80px rgba(0,0,0,0.7);
            }

            /* 화면 반사광 효과 */
            .crt-glare {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 40%);
                z-index: 11;
                border-radius: 4px;
            }

            #ascii-output {
                display: none; 
            }
            
            /* 하단 장식 텍스트 */
            .monitor-footer {
                margin-top: 10px;
                width: 100%;
                text-align: right;
                color: #555;
                font-size: 0.9rem;
                flex-shrink: 0; /* 크기 줄어들지 않게 고정 */
            }

            .noselect {
                user-select: none;
            }
        </style>
    </head>
    <body>
        <div id="container" class="noselect">
            <div class="monitor-header">
                <span>DOOM_OS // VER 6.6.6</span>
                <span><span class="blink">●</span> REC</span>
            </div>

            <div class="screen-wrapper">
                <canvas id="sdl-canvas" style="display: none; width: 320px; height: 200px;"></canvas>
                
                <canvas class="frame" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
                
                <div class="crt-overlay"></div>
                <div class="crt-glare"></div>
            </div>

            <pre id="ascii-output"></pre>
            
            <div class="monitor-footer">
                SYSTEM: ONLINE | RENDERER: ASCII_WASM
            </div>
        </div>

        <script>
            // 공통적으로 Doom 실행 시에 사용할 인자들
            var commonArgs = ["-iwad", "doom1.wad", "-window", "-nogui", "-nomusic", "-config", "default.cfg", "-servername", "doomflare", "-force_software_renderer", "1"];

            var Module = {
                onRuntimeInitialized: () => {
                    console.log("Module initialized, setting up canvas renderer...");

                    // Hide SDL canvas and any canvas that Emscripten might have created automatically
                    const sdlCanvas = document.getElementById("sdl-canvas");
                    if (sdlCanvas) {
                        sdlCanvas.style.display = "none";
                    }
                    const canvases = document.querySelectorAll("canvas");
                    canvases.forEach(canvas => {
                        if (canvas.id !== "canvas") {
                            canvas.style.display = "none";
                        }
                    });
                    
                    // Wait a bit for HEAPU8 to be fully initialized
                    setTimeout(() => {
                        setupRenderer();
                    }, 100);
                },
                noInitialRun: true,
                preRun: () => {
                    Module.FS.createPreloadedFile("", "doom1.wad", "doom1.wad", true, true);
                    Module.FS.createPreloadedFile("", "default.cfg", "default.cfg", true, true);
                },
                printErr: function (text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(" ");
                    console.error(text);
                },
                canvas: document.getElementById("sdl-canvas"),
                print: function (text) {
                    console.log(text);
                },
                setStatus: function (text) {
                    console.log(text);
                }
            };

            function setupRenderer() {
                    const getBufferPtr = Module.cwrap('ascii_get_buffer', 'number', []);
                    const getBufferSize = Module.cwrap('ascii_get_buffer_size', 'number', []);

                    if (!getBufferPtr || !getBufferSize) {
                        console.error("Failed to wrap WASM buffer functions.");
                        return;
                    }

                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d', { alpha: false });  // 알파 채널 비활성화로 성능 향상

                    const ASCII_WIDTH = 240;
                    const ASCII_HEIGHT = 80;

                    // wrapper 영역 크기 가져오기
                    const screenWrapper = document.querySelector('.screen-wrapper');
                    const wrapperRect = screenWrapper.getBoundingClientRect();
                    
                    // wrapper 전체를 캔버스로 채움 (비율 무시 - 게임 화면 짤림 방지)
                    const canvasWidth = wrapperRect.width;
                    const canvasHeight = wrapperRect.height;
                    
                    // devicePixelRatio 고려 (레티나 디스플레이 지원)
                    const dpr = window.devicePixelRatio || 1;
                    const TARGET_CANVAS_WIDTH = Math.round(canvasWidth * dpr);
                    const TARGET_CANVAS_HEIGHT = Math.round(canvasHeight * dpr);

                    const charWidth = TARGET_CANVAS_WIDTH / ASCII_WIDTH;
                    const charHeight = TARGET_CANVAS_HEIGHT / ASCII_HEIGHT;

                    const FONT_SIZE = Math.round(charHeight); 
                    const FONT = `${FONT_SIZE}px "Courier New", monospace`;
                    
                    ctx.font = FONT; 

                    // 내부 해상도 설정 (DPR 반영)
                    canvas.width = TARGET_CANVAS_WIDTH;
                    canvas.height = TARGET_CANVAS_HEIGHT;

                    console.log(`Canvas initialized: ${canvas.width}x${canvas.height} (Wrapper: ${Math.round(canvasWidth)}x${Math.round(canvasHeight)}, DPR: ${dpr})`);
                    console.log(`Character cell size: ${charWidth.toFixed(1)}x${charHeight.toFixed(1)}`);
                
                function getMemoryBuffer() {
                    if (typeof HEAPU8 !== 'undefined' && HEAPU8 && HEAPU8.buffer) {
                        return HEAPU8.buffer;
                    } else if (Module.HEAPU8 && Module.HEAPU8.buffer) {
                        return Module.HEAPU8.buffer;
                    } else if (Module.HEAP8 && Module.HEAP8.buffer) {
                        return Module.HEAP8.buffer;
                    } else if (Module.wasmMemory && Module.wasmMemory.buffer) {
                        return Module.wasmMemory.buffer;
                    }
                    return null;
                }

                const testBuffer = getMemoryBuffer();
                if (!testBuffer) {
                    console.error("Cannot access WASM memory buffer.");
                    return;
                }
                console.log("Memory buffer access confirmed");

                let frameCount = 0;
                let lastLogTime = Date.now();

                    function renderFrame() {
                        try {
                            const bufferPtr = getBufferPtr();
                            const bufferSize = getBufferSize();

                        if (!bufferPtr || !bufferSize) {
                            if (frameCount % 60 === 0) {
                                console.log("Waiting for buffer...", { bufferPtr, bufferSize });
                            }
                            return;
                        }

                        const heapBuffer = getMemoryBuffer();
                        if (!heapBuffer) {
                            console.error("Cannot access memory buffer");
                            return;
                        }

                        const buffer = new Uint8Array(heapBuffer, bufferPtr, bufferSize);
                        
                        // 디버그 로깅 (2초마다)
                        if (frameCount === 0 || Date.now() - lastLogTime > 2000) {
                            console.log("Buffer size:", bufferSize, "Expected:", ASCII_WIDTH * ASCII_HEIGHT * 4);
                            lastLogTime = Date.now();
                        }
                        
                        // 배경 클리어
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.font = FONT;

                        const expectedSize = ASCII_WIDTH * ASCII_HEIGHT * 4;
                        if (buffer.length < expectedSize) {
                            if (frameCount % 60 === 0) {
                                console.warn(`Buffer size mismatch: got ${buffer.length}, expected ${expectedSize}`);
                            }
                            return;
                        }

                        // 최적화된 렌더링 루프
                        let i = 0;
                        const totalCells = ASCII_WIDTH * ASCII_HEIGHT;
                        
                        for (let y = 0; y < ASCII_HEIGHT; y++) {
                            const yPos = y * charHeight + charHeight;
                            
                            for (let x = 0; x < ASCII_WIDTH; x++) {
                                const charCode = buffer[i];
                                const r = buffer[i + 1];
                                const g = buffer[i + 2];
                                const b = buffer[i + 3];
                                i += 4;

                                // 비어있지 않은 셀만 렌더링 (조건 체크 1회로 통합)
                                if (charCode > 32 || r > 10 || g > 10 || b > 10) {
                                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                                    ctx.fillText(String.fromCharCode(charCode), x * charWidth, yPos);
                                }
                            }
                        }
                        
                        frameCount++;
                        
                        // 첫 프레임 로깅
                        if (frameCount === 1) {
                            console.log("First frame rendered successfully");
                        }
                        } catch (e) {
                            console.error("Error during canvas rendering:", e);
                            clearInterval(renderInterval);
                        }
                    }

                    const renderInterval = setInterval(renderFrame, 16); 
                    
                    callMain(commonArgs);
            }

            window.onerror = function (event) {
                console.error("Unhandled error:", event);
            };
        </script>
        <script async type="text/javascript" src="chocolate-doom.js"></script>
    </body>
</html>