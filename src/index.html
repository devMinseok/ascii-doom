<!DOCTYPE html>
<html lang="en-us">
    <head>
        <title>Websockets Doom</title>
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
        <style>
            @font-face {
                font-family: "VT323";
                font-style: normal;
                font-weight: 400;
                src: url(https://fonts.gstatic.com/s/vt323/v12/pxiKyp0ihIEF2isfFJXUdVNF.woff2) format("woff2");
                unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
            }

            * {
                box-sizing: border-box;
            }

            html {
                font-family: "VT323", monospace;
                font-size: 12px;
            }

            body {
                background-color: #111;
                margin: 0;
                padding: 2ch;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
            }

            #container {
                max-width: 1860px;
                margin: auto;
            }

            .frame {
                padding-right: 0;
                margin-left: auto;
                margin-right: auto;
                display: block;
            }

            canvas.frame {
                background-color: black;
            }

            #ascii-output {
                display: none; 
            }
        </style>
    </head>
    <body>
        <div id="container" class="noselect">
            <!-- Hidden canvas for SDL (required for initialization) -->
            <canvas id="sdl-canvas" style="display: none; width: 320px; height: 200px;"></canvas>
            <!-- Visible canvas for ASCII rendering -->
            <canvas class="frame" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
            <pre id="ascii-output"></pre>
        </div>
        <script>
            // 공통적으로 Doom 실행 시에 사용할 인자들
            // - doom1.wad: 기본 WAD 파일
            // - -window, -nogui, -nomusic 등: 웹 환경에 맞게 최소 옵션으로 실행
            // - -force_software_renderer 1: WebGL 대신 소프트웨어 렌더러 사용 강제
            var commonArgs = ["-iwad", "doom1.wad", "-window", "-nogui", "-nomusic", "-config", "default.cfg", "-servername", "doomflare", "-force_software_renderer", "1"];

            var Module = {
                onRuntimeInitialized: () => {
                    console.log("Module initialized, setting up canvas renderer...");

                    // Hide SDL canvas and any canvas that Emscripten might have created automatically
                    const sdlCanvas = document.getElementById("sdl-canvas");
                    if (sdlCanvas) {
                        sdlCanvas.style.display = "none";
                    }
                    const canvases = document.querySelectorAll("canvas");
                    canvases.forEach(canvas => {
                        if (canvas.id !== "canvas") {
                            canvas.style.display = "none";
                        }
                    });
                    
                    // Wait a bit for HEAPU8 to be fully initialized
                    setTimeout(() => {
                        setupRenderer();
                    }, 100);
                },
                noInitialRun: true,
                preRun: () => {
                    Module.FS.createPreloadedFile("", "doom1.wad", "doom1.wad", true, true);
                    Module.FS.createPreloadedFile("", "default.cfg", "default.cfg", true, true);
                },
                printErr: function (text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(" ");
                    console.error(text);
                },
                // SDL이 사용할 실제 캔버스 (숨겨져 있음)
                canvas: document.getElementById("sdl-canvas"),
                print: function (text) {
                    console.log(text);
                },
                setStatus: function (text) {
                    console.log(text);
                }
            };

            function setupRenderer() {
                    // WASM에서 export 한 함수들을 JS에서 호출하기 위해 cwrap 사용
                    // ascii_get_buffer    : AsciiCell 버퍼의 포인터를 반환
                    // ascii_get_buffer_size: AsciiCell 버퍼의 총 바이트 크기 반환
                    const getBufferPtr = Module.cwrap('ascii_get_buffer', 'number', []);
                    const getBufferSize = Module.cwrap('ascii_get_buffer_size', 'number', []);

                    if (!getBufferPtr || !getBufferSize) {
                        console.error("Failed to wrap WASM buffer functions.");
                        return;
                    }

                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');

                    // C 쪽에서 정의된 ASCII 해상도 (i_ascii.h 의 ASCII_WIDTH/HEIGHT)
                    const ASCII_WIDTH = 240;
                    const ASCII_HEIGHT = 80;

                    // 한 문자 셀의 픽셀 크기 (고정 폰트 크기 사용)
                    const FONT_SIZE = 9;
                    const FONT = `${FONT_SIZE}px "Courier New", monospace`;
                    
                    // Calculate character cell size
                    ctx.font = FONT;
                    const charMeasure = ctx.measureText("M");
                    const charWidth = charMeasure.width;
                    const charHeight = FONT_SIZE;

                    canvas.width = ASCII_WIDTH * charWidth;
                    canvas.height = ASCII_HEIGHT * charHeight;
                    
                    console.log(`Canvas initialized: ${canvas.width}x${canvas.height}`);
                    console.log(`Character cell size: ${charWidth}x${charHeight}`);
                
                // 현재 WASM 메모리 버퍼를 얻는 함수
                // Emscripten 설정에 따라 HEAPU8 이나 wasmMemory 등 접근 방법이 달라질 수 있음
                function getMemoryBuffer() {
                    if (typeof HEAPU8 !== 'undefined' && HEAPU8 && HEAPU8.buffer) {
                        return HEAPU8.buffer;
                    } else if (Module.HEAPU8 && Module.HEAPU8.buffer) {
                        return Module.HEAPU8.buffer;
                    } else if (Module.HEAP8 && Module.HEAP8.buffer) {
                        return Module.HEAP8.buffer;
                    } else if (Module.wasmMemory && Module.wasmMemory.buffer) {
                        return Module.wasmMemory.buffer;
                    }
                    return null;
                }

                // Test if we can access memory
                const testBuffer = getMemoryBuffer();
                if (!testBuffer) {
                    console.error("Cannot access WASM memory buffer. Available properties:", Object.keys(Module));
                    return;
                }
                console.log("Memory buffer access confirmed");

                // 렌더링 프레임 수 및 디버깅용 타임스탬프
                let frameCount = 0;
                let lastLogTime = Date.now();

                    function renderFrame() {
                        try {
                            const bufferPtr = getBufferPtr();
                            const bufferSize = getBufferSize();

                        if (!bufferPtr || !bufferSize) {
                            if (frameCount % 60 === 0) {
                                console.log("Waiting for buffer...", { bufferPtr, bufferSize });
                            }
                            return;
                        }

                        // Get fresh memory buffer each frame (may have been reallocated)
                        const heapBuffer = getMemoryBuffer();
                        if (!heapBuffer) {
                            console.error("Cannot access memory buffer");
                            return;
                        }

                        // C++에서 만든 AsciiCell 배열(연속된 구조체 메모리)을 JS에서
                        // 그대로 Uint8Array 로 바라본 뒤, 4바이트 단위로 파싱한다.
                        const buffer = new Uint8Array(heapBuffer, bufferPtr, bufferSize);
                        
                        // Debug: Check if buffer has data
                        if (frameCount === 0 || Date.now() - lastLogTime > 2000) {
                            const sampleData = Array.from(buffer.slice(0, 20));
                            console.log("Buffer sample:", sampleData, "Size:", bufferSize, "Expected:", ASCII_WIDTH * ASCII_HEIGHT * 4);
                            lastLogTime = Date.now();
                        }
                            
                            ctx.fillStyle = 'black';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.font = FONT;

                        // AsciiCell 구조체 레이아웃:
                        //   char    character (1 byte)
                        //   uint8_t r         (1 byte)
                        //   uint8_t g         (1 byte)
                        //   uint8_t b         (1 byte)
                        // → 총 4 바이트가 한 글자 셀을 표현
                        // 따라서 전체 버퍼 크기는 ASCII_WIDTH * ASCII_HEIGHT * 4 바이트가 되어야 함
                        const expectedSize = ASCII_WIDTH * ASCII_HEIGHT * 4;
                        if (buffer.length < expectedSize) {
                            if (frameCount % 60 === 0) {
                                console.warn(`Buffer size mismatch: got ${buffer.length}, expected ${expectedSize}`);
                            }
                        }

                            let i = 0;
                        let hasData = false;
                        let nonZeroCount = 0;
                        
                            for (let y = 0; y < ASCII_HEIGHT; y++) {
                                for (let x = 0; x < ASCII_WIDTH; x++) {
                                if (i + 3 >= buffer.length) break;
                                
                                // Read AsciiCell: character, r, g, b
                                    const charCode = buffer[i];
                                    const r = buffer[i + 1];
                                    const g = buffer[i + 2];
                                    const b = buffer[i + 3];

                                // Check if this cell has any data
                                if (charCode !== 0 || r !== 0 || g !== 0 || b !== 0) {
                                    hasData = true;
                                    nonZeroCount++;
                                }

                                // Only render non-empty cells for better performance
                                if (charCode !== 0 || r !== 0 || g !== 0 || b !== 0) {
                                    const char = charCode > 0 && charCode < 256 ? String.fromCharCode(charCode) : ' ';
                                    
                                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                                    ctx.fillText(char, x * charWidth, y * charHeight + charHeight);
                                }
                                    
                                    i += 4;
                                }
                            }
                        
                        if (frameCount % 60 === 0 && hasData) {
                            console.log(`Rendering frame ${frameCount}, non-zero cells: ${nonZeroCount}/${ASCII_WIDTH * ASCII_HEIGHT}`);
                        }
                        
                        frameCount++;
                        
                        if (frameCount === 1) {
                            console.log("First frame rendered, hasData:", hasData);
                        }
                        } catch (e) {
                            console.error("Error during canvas rendering:", e);
                            clearInterval(renderInterval);
                        }
                    }

                    const renderInterval = setInterval(renderFrame, 16); // ~60 FPS
                    
                    callMain(commonArgs);
            }

            window.onerror = function (event) {
                console.error("Unhandled error:", event);
            };
        </script>
        <script async type="text/javascript" src="chocolate-doom.js"></script>
    </body>
</html>
